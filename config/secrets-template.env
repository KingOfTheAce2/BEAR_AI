# BEAR AI Code Signing Secrets Template
# Copy this file to .env and fill in your actual values
# NEVER commit actual secrets to version control!

# =============================================================================
# WINDOWS CODE SIGNING
# =============================================================================

# Method 1: Traditional Certificate Signing (legacy - OV certs before June 2023)
WINDOWS_CERTIFICATE_THUMBPRINT=your-certificate-thumbprint-here
WINDOWS_CERTIFICATE_BASE64=your-base64-encoded-pfx-file-here
WINDOWS_CERTIFICATE_PASSWORD=your-certificate-password-here

# Method 2: Azure Key Vault Signing (recommended for production)
AZURE_KEY_VAULT_URL=https://your-vault-name.vault.azure.net/
AZURE_CLIENT_ID=your-azure-app-registration-client-id
AZURE_CLIENT_SECRET=your-azure-app-registration-secret
AZURE_TENANT_ID=your-azure-tenant-id
AZURE_CERTIFICATE_NAME=your-certificate-name-in-keyvault

# Method 3: Hardware Security Module (required for new certificates)
WINDOWS_HSM_CONTAINER=your-hsm-container-name
WINDOWS_HSM_KEY=your-hsm-key-name
WINDOWS_HSM_PIN=your-hsm-pin

# Custom sign command (uncomment and modify if using custom signing tool)
# WINDOWS_SIGN_COMMAND=your-custom-sign-command-here

# =============================================================================
# MACOS CODE SIGNING
# =============================================================================

# Required for all macOS signing
APPLE_SIGNING_IDENTITY="Developer ID Application: Your Name (TEAM_ID)"
APPLE_CERTIFICATE=your-base64-encoded-p12-certificate
APPLE_CERTIFICATE_PASSWORD=your-certificate-password

# Required for notarization (Developer ID distribution)
APPLE_ID=your-apple-id@example.com
APPLE_PASSWORD=your-app-specific-password
APPLE_TEAM_ID=your-10-character-team-id

# Alternative: App Store Connect API authentication (optional)
# APPLE_API_ISSUER=your-api-key-issuer-id
# APPLE_API_KEY=your-api-key-id
# APPLE_API_KEY_PATH=path/to/AuthKey_KEYID.p8

# =============================================================================
# LINUX PACKAGE SIGNING
# =============================================================================

# GPG signing for Linux packages
GPG_PRIVATE_KEY=your-base64-encoded-gpg-private-key
GPG_PASSPHRASE=your-gpg-key-passphrase
GPG_KEY_ID=your-gpg-key-id

# =============================================================================
# TAURI UPDATER
# =============================================================================

# Required for Tauri's built-in updater
TAURI_PRIVATE_KEY=your-tauri-updater-private-key
TAURI_KEY_PASSWORD=your-tauri-updater-key-password
TAURI_UPDATER_PUBLIC_KEY=your-tauri-updater-public-key

# =============================================================================
# GITHUB ACTIONS SECRETS
# =============================================================================
# Add these as GitHub repository secrets:
#
# Windows:
# - WINDOWS_CERTIFICATE_THUMBPRINT
# - WINDOWS_CERTIFICATE_BASE64
# - WINDOWS_CERTIFICATE_PASSWORD
# OR
# - AZURE_KEY_VAULT_URL
# - AZURE_CLIENT_ID
# - AZURE_CLIENT_SECRET
# - AZURE_TENANT_ID
# - AZURE_CERTIFICATE_NAME
#
# macOS:
# - APPLE_SIGNING_IDENTITY
# - APPLE_CERTIFICATE
# - APPLE_CERTIFICATE_PASSWORD
# - APPLE_ID
# - APPLE_PASSWORD
# - APPLE_TEAM_ID
#
# Linux:
# - GPG_PRIVATE_KEY
# - GPG_PASSPHRASE
# - GPG_KEY_ID
#
# Updater:
# - TAURI_PRIVATE_KEY
# - TAURI_KEY_PASSWORD
# - TAURI_UPDATER_PUBLIC_KEY

# =============================================================================
# CERTIFICATE GENERATION COMMANDS
# =============================================================================

# Windows Certificate Export (PowerShell):
# $cert = Get-ChildItem -Path Cert:\CurrentUser\My | Where-Object {$_.Subject -like "*Your Company*"}
# $password = ConvertTo-SecureString -String "your-password" -Force -AsPlainText
# Export-PfxCertificate -Cert $cert -FilePath "certificate.pfx" -Password $password
# $base64 = [Convert]::ToBase64String([IO.File]::ReadAllBytes("certificate.pfx"))
# Write-Output $base64

# macOS Certificate Export:
# 1. Export from Keychain Access as .p12 file
# 2. Convert to base64: base64 -i certificate.p12 -o certificate.txt

# Linux GPG Key Generation:
# gpg --full-generate-key
# gpg --armor --export-secret-keys your-email@domain.com > private.key
# base64 -w 0 private.key > private.key.base64

# Tauri Updater Key Generation:
# npm run tauri signer generate -- -w ~/.tauri/myapp.key
# The public key will be displayed in the terminal

# =============================================================================
# VERIFICATION COMMANDS
# =============================================================================

# Windows Signature Verification:
# Get-AuthenticodeSignature "path\to\executable.exe"

# macOS Signature Verification:
# codesign -dv --verbose=4 "path/to/App.app"
# spctl -a -vvv "path/to/App.app"

# Linux Package Verification:
# gpg --verify package.sig package
# dpkg-sig --verify package.deb
# rpm --checksig package.rpm

# =============================================================================
# TROUBLESHOOTING
# =============================================================================

# Windows Common Issues:
# - Certificate not found: Check Local Machine certificate store
# - Timestamp server error: Try alternative timestamp servers
# - HSM not detected: Verify drivers and connection

# macOS Common Issues:
# - Identity not found: Check keychain and unlock if needed
# - Notarization fails: Verify entitlements and all binaries signed
# - Gatekeeper blocks: Ensure notarization completed

# Linux Common Issues:
# - GPG key not found: Import key with correct passphrase
# - Permission denied: Check file permissions and GPG agent
# - Verification fails: Ensure public key is correctly distributed